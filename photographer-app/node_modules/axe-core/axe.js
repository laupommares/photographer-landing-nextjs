/*! axe v4.11.1
 * Copyright (c) 2015 - 2026 Deque Systems, Inc.
 *
 * Your use of this Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * This entire copyright notice must appear in every copy of this file you
 * distribute or in any file that contains substantial portions of this source
 * code.
 */
(function axeFunction(window) {
  var global = window;
  var document = window.document;
  'use strict';
  function _typeof(o) {
    '@babel/helpers - typeof';
    return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function(o) {
      return typeof o;
    } : function(o) {
      return o && 'function' == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? 'symbol' : typeof o;
    }, _typeof(o);
  }
  var axe = axe || {};
  axe.version = '4.11.1';
  if (typeof define === 'function' && define.amd) {
    define('axe-core', [], function() {
      return axe;
    });
  }
  if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports && typeof axeFunction.toString === 'function') {
    axe.source = '(' + axeFunction.toString() + ')(typeof window === "object" ? window : this);';
    module.exports = axe;
  }
  if (typeof window.getComputedStyle === 'function') {
    window.axe = axe;
  }
  var commons;
  'use strict';
  var _excluded = [ 'precision', 'format', 'inGamut' ], _excluded2 = [ 'space' ], _excluded3 = [ 'algorithm' ], _excluded4 = [ 'method' ], _excluded5 = [ 'maxDeltaE', 'deltaEMethod', 'steps', 'maxSteps' ], _excluded6 = [ 'variant' ], _excluded7 = [ 'matches' ], _excluded8 = [ 'chromium' ], _excluded9 = [ 'noImplicit' ], _excluded0 = [ 'noPresentational' ], _excluded1 = [ 'node' ], _excluded10 = [ 'relatedNodes' ], _excluded11 = [ 'node' ], _excluded12 = [ 'node' ], _excluded13 = [ 'environmentData' ], _excluded14 = [ 'environmentData' ], _excluded15 = [ 'environmentData' ], _excluded16 = [ 'environmentData' ], _excluded17 = [ 'environmentData' ];
  function _toArray(r) {
    return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
  }
  function _wrapNativeSuper(t) {
    var r = 'function' == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_isNativeFunction(t)) {
        return t;
      }
      if ('function' != typeof t) {
        throw new TypeError('Super expression must either be null or a function');
      }
      if (void 0 !== r) {
        if (r.has(t)) {
          return r.get(t);
        }
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf('[native code]');
    } catch (n) {
      return 'function' == typeof t;
    }
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) {
      return Reflect.construct.apply(null, arguments);
    }
    var o = [ null ];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _objectWithoutProperties(e, t) {
    if (null == e) {
      return {};
    }
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) {
        o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
    }
    return i;
  }
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) {
      return {};
    }
    var t = {};
    for (var n in r) {
      if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) {
          continue;
        }
        t[n] = r[n];
      }
    }
    return t;
  }
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _possibleConstructorReturn(t, e) {
    if (e && ('object' == _typeof(e) || 'function' == typeof e)) {
      return e;
    }
    if (void 0 !== e) {
      throw new TypeError('Derived constructors may only return object or undefined');
    }
    return _assertThisInitialized(t);
  }
  function _assertThisInitialized(e) {
    if (void 0 === e) {
      throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
    }
    return e;
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ('function' != typeof e && null !== e) {
      throw new TypeError('Super expression must either be null or a function');
    }
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, 'prototype', {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) {
          ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
      }
      return n;
    }, _extends.apply(null, arguments);
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
  }
  function _iterableToArray(r) {
    if ('undefined' != typeof Symbol && null != r[Symbol.iterator] || null != r['@@iterator']) {
      return Array.from(r);
    }
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) {
      return _arrayLikeToArray(r);
    }
  }
  function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
  }
  function _classPrivateMethodInitSpec(e, a) {
    _checkPrivateRedeclaration(e, a), a.add(e);
  }
  function _checkPrivateRedeclaration(e, t) {
    if (t.has(e)) {
      throw new TypeError('Cannot initialize the same private elements twice on an object');
    }
  }
  function _classPrivateFieldGet(s, a) {
    return s.get(_assertClassBrand(s, a));
  }
  function _classPrivateFieldSet(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
  }
  function _assertClassBrand(e, t, n) {
    if ('function' == typeof e ? e === t : e.has(t)) {
      return arguments.length < 3 ? t : n;
    }
    throw new TypeError('Private element is not present on this object');
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : 'undefined' != typeof Symbol && r[Symbol.iterator] || r['@@iterator'];
    if (null != t) {
      var e, n, i, u, a = [], f = !0, o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) {
            return;
          }
          f = !1;
        } else {
          for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0) {}
        }
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t['return'] && (u = t['return'](), Object(u) !== u)) {
            return;
          }
        } finally {
          if (o) {
            throw n;
          }
        }
      }
      return a;
    }
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) {
      return r;
    }
  }
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), 
      Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), 
    Object.defineProperty(e, 'prototype', {
      writable: !1
    }), e;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, 'string');
    return 'symbol' == _typeof(i) ? i : i + '';
  }
  function _toPrimitive(t, r) {
    if ('object' != _typeof(t) || !t) {
      return t;
    }
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || 'default');
      if ('object' != _typeof(i)) {
        return i;
      }
      throw new TypeError('@@toPrimitive must return a primitive value.');
    }
    return ('string' === r ? String : Number)(t);
  }
  function _createForOfIteratorHelper(r, e) {
    var t = 'undefined' != typeof Symbol && r[Symbol.iterator] || r['@@iterator'];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && 'number' == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F() {};
        return {
          s: F,
          n: function n() {
            return _n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[_n++]
            };
          },
          e: function e(r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
    }
    var o, a = !0, u = !1;
    return {
      s: function s() {
        t = t.call(r);
      },
      n: function n() {
        var r = t.next();
        return a = r.done, r;
      },
      e: function e(r) {
        u = !0, o = r;
      },
      f: function f() {
        try {
          a || null == t['return'] || t['return']();
        } finally {
          if (u) {
            throw o;
          }
        }
      }
    };
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ('string' == typeof r) {
        return _arrayLikeToArray(r, a);
      }
      var t = {}.toString.call(r).slice(8, -1);
      return 'Object' === t && r.constructor && (t = r.constructor.name), 'Map' === t || 'Set' === t ? Array.from(r) : 'Arguments' === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) {
      n[e] = r[e];
    }
    return n;
  }
  function _typeof(o) {
    '@babel/helpers - typeof';
    return _typeof = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function(o) {
      return typeof o;
    } : function(o) {
      return o && 'function' == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? 'symbol' : typeof o;
    }, _typeof(o);
  }
  (function(_Class_brand, _path, _CSS, _space, _r, _g, _b, _red, _green, _blue, _Class3_brand) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __defNormalProp = function __defNormalProp(obj, key, value) {
      return key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value
      }) : obj[key] = value;
    };
    var __markAsModule = function __markAsModule(target) {
      return __defProp(target, '__esModule', {
        value: true
      });
    };
    var __commonJS = function __commonJS(cb, mod) {
      return function() {
        return mod || cb((mod = {
          exports: {}
        }).exports, mod), mod.exports;
      };
    };
    var __export = function __export(target, all) {
      for (var name in all) {
        __defProp(target, name, {
          get: all[name],
          enumerable: true
        });
      }
    };
    var __exportStar = function __exportStar(target, module, desc) {
      if (module && _typeof(module) === 'object' || typeof module === 'function') {
        var _iterator = _createForOfIteratorHelper(__getOwnPropNames(module)), _step;
        try {
          var _loop = function _loop() {
            var key = _step.value;
            if (!__hasOwnProp.call(target, key) && key !== 'default') {
              __defProp(target, key, {
                get: function get() {
                  return module[key];
                },
                enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable
              });
            }
          };
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      return target;
    };
    var __toModule = function __toModule(module) {
      return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, 'default', module && module.__esModule && 'default' in module ? {
        get: function get() {
          return module['default'];
        },
        enumerable: true
      } : {
        value: module,
        enumerable: true
      })), module);
    };
    var __publicField = function __publicField(obj, key, value) {
      __defNormalProp(obj, _typeof(key) !== 'symbol' ? key + '' : key, value);
      return value;
    };
    var require_es6_promise = __commonJS(function(exports, module) {
      (function(global2, factory) {
        _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global2.ES6Promise = factory();
      })(exports, function() {
        'use strict';
        function objectOrFunction(x) {
          var type2 = _typeof(x);
          return x !== null && (type2 === 'object' || type2 === 'function');
        }
        function isFunction(x) {
          return typeof x === 'function';
        }
        var _isArray = void 0;
        if (Array.isArray) {
          _isArray = Array.isArray;
        } else {
          _isArray = function _isArray(x) {
            return Object.prototype.toString.call(x) === '[object Array]';
          };
        }
        var isArray = _isArray;
        var len = 0;
        var vertxNext = void 0;
        var customSchedulerFn = void 0;
        var asap = function asap2(callback, arg) {
          queue2[len] = callback;
          queue2[len + 1] = arg;
          len += 2;
          if (len === 2) {
            if (customSchedulerFn) {
              customSchedulerFn(flush);
            } else {
              scheduleFlush();
            }
          }
        };
        function setScheduler(scheduleFn) {
          customSchedulerFn = scheduleFn;
        }
        function setAsap(asapFn) {
          asap = asapFn;
        }
        var browserWindow = typeof window !== 'undefined' ? window : void 0;
        var browserGlobal = browserWindow || {};
        var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
        var isNode2 = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
        function useNextTick() {
          return function() {
            return process.nextTick(flush);
          };
        }
        function useVertxTimer() {
          if (typeof vertxNext !== 'undefined') {
            return function() {
              vertxNext(flush);
            };
          }
          return useSetTimeout();
        }
        function useMutationObserver() {
          var iterations = 0;
          var observer = new BrowserMutationObserver(flush);
          var node = document.createTextNode('');
          observer.observe(node, {
            characterData: true
          });
          return function() {
            node.data = iterations = ++iterations % 2;
          };
        }
        function useMessageChannel() {
          var channel = new MessageChannel();
          channel.port1.onmessage = flush;
          return function() {
            return channel.port2.postMessage(0);
          };
        }
        function useSetTimeout() {
          var globalSetTimeout = setTimeout;
          return function() {
            return globalSetTimeout(flush, 1);
          };
        }
        var queue2 = new Array(1e3);
        function flush() {
          for (var i = 0; i < len; i += 2) {
            var callback = queue2[i];
            var arg = queue2[i + 1];
            callback(arg);
            queue2[i] = void 0;
            queue2[i + 1] = void 0;
          }
          len = 0;
        }
        function attemptVertx() {
          try {
            var vertx = Function('return this')().require('vertx');
            vertxNext = vertx.runOnLoop || vertx.runOnContext;
            return useVertxTimer();
          } catch (e) {
            return useSetTimeout();
          }
        }
        var scheduleFlush = void 0;
        if (isNode2) {
          scheduleFlush = useNextTick();
        } else if (BrowserMutationObserver) {
          scheduleFlush = useMutationObserver();
        } else if (isWorker) {
          scheduleFlush = useMessageChannel();
        } else if (browserWindow === void 0 && true) {
          scheduleFlush = attemptVertx();
        } else {
          scheduleFlush = useSetTimeout();
        }
        function then(onFulfillment, onRejection) {
          var parent = this;
          var child = new this.constructor(noop3);
          if (child[PROMISE_ID] === void 0) {
            makePromise(child);
          }
          var _state = parent._state;
          if (_state) {
            var callback = arguments[_state - 1];
            asap(function() {
              return invokeCallback(_state, child, callback, parent._result);
            });
          } else {
            subscribe2(parent, child, onFulfillment, onRejection);
          }
          return child;
        }
        function resolve$1(object) {
          var Constructor = this;
          if (object && _typeof(object) === 'object' && object.constructor === Constructor) {
            return object;
          }
          var promise = new Constructor(noop3);
          resolve(promise, object);
          return promise;
        }
        var PROMISE_ID = Math.random().toString(36).substring(2);
        function noop3() {}
        var PENDING = void 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        function selfFulfillment() {
          return new TypeError('You cannot resolve a promise with itself');
        }
        function cannotReturnOwn() {
          return new TypeError('A promises callback cannot return that same promise.');
        }
        function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
          try {
            then$$1.call(value, fulfillmentHandler, rejectionHandler);
          } catch (e) {
            return e;
          }
        }
        function handleForeignThenable(promise, thenable, then$$1) {
          asap(function(promise2) {
            var sealed = false;
            var error = tryThen(then$$1, thenable, function(value) {
              if (sealed) {
                return;
              }
              sealed = true;
              if (thenable !== value) {
                resolve(promise2, value);
              } else {
                fulfill(promise2, value);
              }
            }, function(reason) {
              if (sealed) {
                return;
              }
              sealed = true;
              reject(promise2, reason);
            }, 'Settle: ' + (promise2._label || ' unknown promise'));
            if (!sealed && error) {
              sealed = true;
              reject(promise2, error);
            }
          }, promise);
        }
        function handleOwnThenable(promise, thenable) {
          if (thenable._state === FULFILLED) {
            fulfill(promise, thenable._result);
          } else if (thenable._state === REJECTED) {
            reject(promise, thenable._result);
          } else {
            subscribe2(thenable, void 0, function(value) {
              return resolve(promise, value);
            }, function(reason) {
              return reject(promise, reason);
            });
          }
        }
        function handleMaybeThenable(promise, maybeThenable, then$$1) {
          if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
            handleOwnThenable(promise, maybeThenable);
          } else {
            if (then$$1 === void 0) {
              fulfill(promise, maybeThenable);
            } else if (isFunction(then$$1)) {
              handleForeignThenable(promise, maybeThenable, then$$1);
            } else {
              fulfill(promise, maybeThenable);
            }
          }
        }
        function resolve(promise, value) {
          if (promise === value) {
            reject(promise, selfFulfillment());
          } else if (objectOrFunction(value)) {
            var then$$1 = void 0;
            try {
              then$$1 = value.then;
            } catch (error) {
              reject(promise, error);
              return;
            }
            handleMaybeThenable(promise, value, then$$1);
          } else {
            fulfill(promise, value);
          }
        }
        function publishRejection(promise) {
          if (promise._onerror) {
            promise._onerror(promise._result);
          }
          publish(promise);
        }
        function fulfill(promise, value) {
          if (promise._state !== PENDING) {
            return;
          }
          promise._result = value;
          promise._state = FULFILLED;
          if (promise._subscribers.length !== 0) {
            asap(publish, promise);
          }
        }
        function reject(promise, reason) {
          if (promise._state !== PENDING) {
            return;
          }
          promise._state = REJECTED;
          promise._result = reason;
          asap(publishRejection, promise);
        }
        function subscribe2(parent, child, onFulfillment, onRejection) {
          var _subscribers = parent._subscribers;
          var length = _subscribers.length;
          parent._onerror = null;
          _subscribers[length] = child;
          _subscribers[length + FULFILLED] = onFulfillment;
          _subscribers[length + REJECTED] = onRejection;
          if (length === 0 && parent._state) {
            asap(publish, parent);
          }
        }
        function publish(promise) {
          var subscribers = promise._subscribers;
          var settled = promise._state;
          if (subscribers.length === 0) {
            return;
          }
          var child = void 0, callback = void 0, detail = promise._result;
          for (var i = 0; i < subscribers.length; i += 3) {
            child = subscribers[i];
            callback = subscribers[i + settled];
            if (child) {
              invokeCallback(settled, child, callback, detail);
            } else {
              callback(detail);
            }
          }
          promise._subscribers.length = 0;
        }
        function invokeCallback(settled, promise, callback, detail) {
          var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;
          if (hasCallback) {
            try {
              value = callback(detail);
            } catch (e) {
              succeeded = false;
              error = e;
            }
            if (promise === value) {
              reject(promise, cannotReturnOwn());
              return;
            }
          } else {
            value = detail;
          }
          if (promise._state !== PENDING) {} else if (hasCallback && succeeded) {
            resolve(promise, value);
          } else if (succeeded === false) {
            reject(promise, error);
          } else if (settled === FULFILLED) {
            fulfill(promise, value);
          } else if (settled === REJECTED) {
            reject(promise, value);
          }
        }
        function initializePromise(promise, resolver) {
          try {
            resolver(function resolvePromise(value) {
              resolve(promise, value);
            }, function rejectPromise(reason) {
              reject(promise, reason);
            });
          } catch (e) {
            reject(promise, e);
          }
        }
        var id = 0;
        function nextId() {
          return id++;
        }
        function makePromise(promise) {
          promise[PROMISE_ID] = id++;
          promise._state = void 0;
          promise._result = void 0;
          promise._subscribers = [];
        }
        function validationError() {
          return new Error('Array Methods must be provided an Array');
        }
        var Enumerator = function() {
          function Enumerator2(Constructor, input) {
            this._instanceConstructor = Constructor;
            this.promise = new Constructor(noop3);
            if (!this.promise[PROMISE_ID]) {
              makePromise(this.promise);
            }
            if (isArray(input)) {
              this.length = input.length;
              this._remaining = input.length;
              this._result = new Array(this.length);
              if (this.length === 0) {
                fulfill(this.promise, this._result);
              } else {
                this.length = this.length || 0;
                this._enumerate(input);
                if (this._remaining === 0) {
                  fulfill(this.promise, this._result);
                }
              }
            } else {
              reject(this.promise, validationError());
            }
          }
          Enumerator2.prototype._enumerate = function _enumerate(input) {
            for (var i = 0; this._state === PENDING && i < input.length; i++) {
              this._eachEntry(input[i], i);
            }
          };
          Enumerator2.prototype._eachEntry = function _eachEntry(entry, i) {
            var c4 = this._instanceConstructor;
            var resolve$$1 = c4.resolve;
            if (resolve$$1 === resolve$1) {
              var _then = void 0;
              var error = void 0;
              var didError = false;
              try {
                _then = entry.then;
              } catch (e) {
                didError = true;
                error = e;
              }
              if (_then === then && entry._state !== PENDING) {
                this._settledAt(entry._state, i, entry._result);
              } else if (typeof _then !== 'function') {
                this._remaining--;
                this._result[i] = entry;
              } else if (c4 === Promise$1) {
                var promise = new c4(noop3);
                if (didError) {
                  reject(promise, error);
                } else {
                  handleMaybeThenable(promise, entry, _then);
                }
                this._willSettleAt(promise, i);
              } else {
                this._willSettleAt(new c4(function(resolve$$12) {
                  return resolve$$12(entry);
                }), i);
              }
            } else {
              this._willSettleAt(resolve$$1(entry), i);
            }
          };
          Enumerator2.prototype._settledAt = function _settledAt(state, i, value) {
            var promise = this.promise;
            if (promise._state === PENDING) {
              this._remaining--;
              if (state === REJECTED) {
                reject(promise, value);
              } else {
                this._result[i] = value;
              }
            }
            if (this._remaining === 0) {
              fulfill(promise, this._result);
            }
          };
          Enumerator2.prototype._willSettleAt = function _willSettleAt(promise, i) {
            var enumerator = this;
            subscribe2(promise, void 0, function(value) {
              return enumerator._settledAt(FULFILLED, i, value);
            }, function(reason) {
              return enumerator._settledAt(REJECTED, i, reason);
            });
          };
          return Enumerator2;
        }();
        function all(entries) {
          return new Enumerator(this, entries).promise;
        }
        function race(entries) {
          var Constructor = this;
          if (!isArray(entries)) {
            return new Constructor(function(_, reject2) {
              return reject2(new TypeError('You must pass an array to race.'));
            });
          } else {
            return new Constructor(function(resolve2, reject2) {
              var length = entries.length;
              for (var i = 0; i < length; i++) {
                Constructor.resolve(entries[i]).then(resolve2, reject2);
              }
            });
          }
        }
        function reject$1(reason) {
          var Constructor = this;
          var promise = new Constructor(noop3);
          reject(promise, reason);
          return promise;
        }
        function needsResolver() {
          throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
        }
        function needsNew() {
          throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
        }
        var Promise$1 = function() {
          function Promise2(resolver) {
            this[PROMISE_ID] = nextId();
            this._result = this._state = void 0;
            this._subscribers = [];
            if (noop3 !== resolver) {
      