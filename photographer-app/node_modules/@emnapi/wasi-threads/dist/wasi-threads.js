(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.wasiThreads = {}));
})(this, (function (exports) {
    var _WebAssembly = typeof WebAssembly !== 'undefined'
        ? WebAssembly
        : typeof WXWebAssembly !== 'undefined'
            ? WXWebAssembly
            : undefined;
    var ENVIRONMENT_IS_NODE = typeof process === 'object' && process !== null &&
        typeof process.versions === 'object' && process.versions !== null &&
        typeof process.versions.node === 'string';
    function getPostMessage(options) {
        return typeof (options === null || options === void 0 ? void 0 : options.postMessage) === 'function'
            ? options.postMessage
            : typeof postMessage === 'function'
                ? postMessage
                : undefined;
    }
    function serizeErrorToBuffer(sab, code, error) {
        var i32array = new Int32Array(sab);
        Atomics.store(i32array, 0, code);
        if (code > 1 && error) {
            var name_1 = error.name;
            var message = error.message;
            var stack = error.stack;
            var nameBuffer = new TextEncoder().encode(name_1);
            var messageBuffer = new TextEncoder().encode(message);
            var stackBuffer = new TextEncoder().encode(stack);
            Atomics.store(i32array, 1, nameBuffer.length);
            Atomics.store(i32array, 2, messageBuffer.length);
            Atomics.store(i32array, 3, stackBuffer.length);
            var buffer = new Uint8Array(sab);
            buffer.set(nameBuffer, 16);
            buffer.set(messageBuffer, 16 + nameBuffer.length);
            buffer.set(stackBuffer, 16 + nameBuffer.length + messageBuffer.length);
        }
    }
    function deserizeErrorFromBuffer(sab) {
        var _a, _b;
        var i32array = new Int32Array(sab);
        var status = Atomics.load(i32array, 0);
        if (status <= 1) {
            return null;
        }
        var nameLength = Atomics.load(i32array, 1);
        var messageLength = Atomics.load(i32array, 2);
        var stackLength = Atomics.load(i32array, 3);
        var buffer = new Uint8Array(sab);
        var nameBuffer = buffer.slice(16, 16 + nameLength);
        var messageBuffer = buffer.slice(16 + nameLength, 16 + nameLength + messageLength);
        var stackBuffer = buffer.slice(16 + nameLength + messageLength, 16 + nameLength + messageLength + stackLength);
        var name = new TextDecoder().decode(nameBuffer);
        var message = new TextDecoder().decode(messageBuffer);
        var stack = new TextDecoder().decode(stackBuffer);
        var ErrorConstructor = (_a = globalThis[name]) !== null && _a !== void 0 ? _a : (name === 'RuntimeError' ? ((_b = _WebAssembly.RuntimeError) !== null && _b !== void 0 ? _b : Error) : Error);
        var error = new ErrorConstructor(message);
        Object.defineProperty(error, 'stack', {
            value: stack,
            writable: true,
            enumerable: false,
            configurable: true
        });
        return error;
    }
    /** @public */
    function isSharedArrayBuffer(value) {
        return ((typeof SharedArrayBuffer === 'function' && value instanceof SharedArrayBuffer) ||
            (Object.prototype.toString.call(value) === '[object SharedArrayBuffer]'));
    }
    /** @public */
    function isTrapError(e) {
        try {
            return e instanceof _WebAssembly.RuntimeError;
        }
        catch (_) {
            return false;
        }
    }

    function createMessage(type, payload) {
        return {
            __emnapi__: {
                type: type,
                payload: payload
            }
        };
    }

    var WASI_THREADS_MAX_TID = 0x1FFFFFFF;
    function checkSharedWasmMemory(wasmMemory) {
        if (wasmMemory) {
            if (!isSharedArrayBuffer(wasmMemory.buffer)) {
                throw new Error('Multithread features require shared wasm memory. ' +
                    'Try to compile with `-matomics -mbulk-memory` and use `--import-memory --shared-memory` during linking, ' +
                    'then create WebAssembly.Memory with `shared: true` option');
            }
        }
        else {
            if (typeof SharedArrayBuffer === 'undefined') {
                throw new Error('Current environment does not support SharedArrayBuffer, threads are not available!');
            }
        }
    }
    function getReuseWorker(value) {
        var _a;
        if (typeof value === 'boolean') {
            return value ? { size: 0, strict: false } : false;
        }
        if (typeof value === 'number') {
            if (!(value >= 0)) {
                throw new RangeError('reuseWorker: size must be a non-negative integer');
            }
            return { size: value, strict: false };
        }
        if (!value) {
            return false;
        }
        var size = (_a = Number(value.size)) !== null && _a !== void 0 ? _a : 0;
        var strict = Boolean(value.strict);
        if (!(size > 0) && strict) {
            throw new RangeError('reuseWorker: size must be set to positive integer if strict is set to true');
        }
        return { size: size, strict: strict };
    }
    var nextWorkerID = 0;
    /** @public */
    var ThreadManager = /*#__PURE__*/ (function () {
        function ThreadManager(options) {
            var _a;
            this.unusedWorkers = [];
            this.runningWorkers = [];
            this.pthreads = Object.create(null);
            this.wasmModule = null;
            this.wasmMemory = null;
            this.messageEvents = new WeakMap();
            if (!options) {
                throw new TypeError('ThreadManager(): options is not provided');
            }
            if ('childThread' in options) {
                this._childThread = Boolean(options.childThread);
            }
            else {
                this._childThread = false;
            }
            if (this._childThread) {
                this._onCreateWorker = undefined;
                this._reuseWorker = false;
                this._beforeLoad = undefined;
            }
            else {
                this._onCreateWorker = options.onCreateWorker;
                this._reuseWorker = getReuseWorker(options.reuseWorker);
                this._beforeLoad = options.beforeLoad;
            }
            this.printErr = (_a = options.printErr) !== null && _a !== void 0 ? _a : console.error.bind(console);
        }
        Object.defineProperty(ThreadManager.prototype, "nextWorkerID", {
            get: function () { return nextWorkerID; },
            enumerable: false,
            configurable: true
        });
        ThreadManager.prototype.init = function () {
            if (!this._childThread) {
                this.initMainThread();
            }
        };
        ThreadManager.prototype.initMainThread = function () {
            this.preparePool();
        };
        ThreadManager.prototype.preparePool = function () {
            if (this._reuseWorker) {
                if (this._reuseWorker.size) {
                    var pthreadPool